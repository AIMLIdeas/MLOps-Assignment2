name: CD - Deploy to AWS

on:
  # Trigger on successful CI completion or manual dispatch
  workflow_run:
    workflows: ["CI - Test Docker Image"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy (default: latest commit SHA)'
        required: false
        type: string
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  deploy:
    name: Deploy to AWS EKS
    # Only deploy if CI workflow succeeded (image was tested successfully)
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment || 'production' }}
      url: ${{ steps.get-url.outputs.service_url }}
    permissions:
      contents: read
      packages: read
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify image availability
        run: |
          echo "## Deployment Starting ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Deploying tested image that passed CI" >> $GITHUB_STEP_SUMMARY
          echo "- **Image tag (commit SHA):** \`${{ github.event.workflow_run.head_sha || github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set image tag
        id: image-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ inputs.image_tag }}" ]; then
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "tag=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --region us-east-1 --name mnist-classifier-cluster

      - name: Deploy to EKS
        env:
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          echo "Deploying image: ghcr.io/aimlideas/mlops-assignment2/cats-dogs-classifier:${IMAGE_TAG}"
          
          # Apply Kubernetes manifests
          kubectl apply -f deployment/kubernetes/namespace.yaml
          kubectl apply -f deployment/kubernetes/configmap.yaml
          kubectl apply -f deployment/kubernetes/secret-ghcr.yaml
          kubectl apply -f deployment/kubernetes/deployment.yaml
          kubectl apply -f deployment/kubernetes/service.yaml
          kubectl apply -f deployment/kubernetes/hpa.yaml
          
          # Update deployment with specific tested image
          kubectl set image deployment/cat-dogs-deployment \
            cat-dogs-classifier=ghcr.io/aimlideas/mlops-assignment2/cats-dogs-classifier:${IMAGE_TAG} \
            -n mlops

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/cat-dogs-deployment -n mlops
          kubectl get pods -n mlops -l app=cat-dogs-classifier
          kubectl get svc -n mlops

      - name: Run smoke tests
        run: |
          echo "Waiting for service to be ready..."
          sleep 30
          SERVICE_URL=$(kubectl get svc cat-dogs-service -n mlops -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$SERVICE_URL" ]; then
            curl -f http://$SERVICE_URL:8000/health || exit 1
            echo "Deployment successful! Service is healthy."
          else
            echo "Warning: LoadBalancer URL not yet available"
          fi
